#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1in
\topmargin 1in
\rightmargin 1in
\bottommargin 1in
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
R Programming - Notes
\end_layout

\begin_layout Author
Tanner Prestegard
\end_layout

\begin_layout Date
Course taken from 3/2/2015 - 3/28/2015
\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Subsection*

\series bold
Writing code / setting your working directory
\end_layout

\begin_layout Itemize
In R, you can use 
\family typewriter
getwd()
\family default
 to get the current directory you're working in.
\end_layout

\begin_layout Itemize
dir() gives a list of files that are in your current directory.
\end_layout

\begin_layout Itemize
If you try to call files that aren't in your working directory, R will not
 be able to find them.
 So you can either copy the file into your working directory or change directori
es.
\end_layout

\begin_layout Itemize
For this course, it may be useful to put these files into a single directory
 to help keep things organized.
\end_layout

\begin_layout Itemize
To load code into R, use source(
\begin_inset Quotes eld
\end_inset

mycode.R
\begin_inset Quotes erd
\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Subsection*
History of R
\end_layout

\begin_layout Itemize
R is a dialect of the S language.
\end_layout

\begin_deeper
\begin_layout Itemize
S was initiated in 1976 as an internal statistical analysis environment
 - originally implemented as a series of Fortran libraries.
\end_layout

\end_deeper
\begin_layout Itemize
Features of R
\end_layout

\begin_deeper
\begin_layout Itemize
Quite lean in terms of software, functionality is divided into modular packages.
\end_layout

\begin_layout Itemize
Sophisticated graphics capabilities.
\end_layout

\begin_layout Itemize
Userful for interactive work but also contains a powerful programming language
 for developing new tools.
\end_layout

\begin_layout Itemize
Active and vibrant user community - R-help and R-devel mailing lists and
 Stack Overflow.
\end_layout

\end_deeper
\begin_layout Itemize
Drawbacks of R
\end_layout

\begin_deeper
\begin_layout Itemize
Essentially based on 40 year old technology.
\end_layout

\begin_layout Itemize
Little built-in support for dynamic or 3D graphics.
\end_layout

\begin_layout Itemize
Functionality is based on consumer demand and user contributions.
\end_layout

\begin_layout Itemize
Objects must generally be stored in physical memory - can be a problem due
 to increasing size of datasets.
\end_layout

\end_deeper
\begin_layout Itemize
The R system is divided into two conceptual parts.
\end_layout

\begin_deeper
\begin_layout Itemize
The 
\begin_inset Quotes eld
\end_inset

base
\begin_inset Quotes erd
\end_inset

 R system that you download from CRAN.
\end_layout

\begin_deeper
\begin_layout Itemize
Base package
\end_layout

\begin_layout Itemize
Packages like: utils, stats, datasets, graphics, grDevices, grid, methods,
 tools, parallel, compiler, splines, tcltk, stats4.
\end_layout

\begin_layout Itemize
There are also recommended packages: boot, class, cluster, codetools, foreign,
 KernSmooth, lattice, mgcv, nlme, rpart, survival, MASS, spatial, nnet,
 Matrix.
\end_layout

\end_deeper
\begin_layout Itemize
Everything else.
\end_layout

\begin_deeper
\begin_layout Itemize
~4000 packages on CRAN developed by users.
 Note: CRAN has quality standards for their packages.
\end_layout

\begin_layout Itemize
Packages available on people's personal websites.
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Some R resources (all available on CRAN:
\end_layout

\begin_deeper
\begin_layout Itemize
An Introduction to R
\end_layout

\begin_layout Itemize
Writing R Extensions (for developing R packages)
\end_layout

\begin_layout Itemize
R Data Import/Export (useful for getting data into and out of R)
\end_layout

\begin_layout Itemize
R Installation and Administration (useful for building R from source)
\end_layout

\begin_layout Itemize
R Internals (very low level)
\end_layout

\end_deeper
\begin_layout Subsection*
R Console Input and Evaluation
\end_layout

\begin_layout Itemize
Assignment operator: <-
\end_layout

\begin_deeper
\begin_layout Itemize
Example: x <- 1 assigns the value 1 to x.
\end_layout

\begin_layout Itemize
Example: msg <- 
\begin_inset Quotes eld
\end_inset

hello
\begin_inset Quotes erd
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Comments: #
\end_layout

\begin_layout Itemize
Auto-printing: assign a value to x, then just enter x.
 The value will be auto-printed.
\end_layout

\begin_layout Itemize
Sequence: x <- 1:20
\end_layout

\begin_layout Subsection*
R Objects and Attributes
\end_layout

\begin_layout Itemize
R has five basic or 
\begin_inset Quotes eld
\end_inset

atomic
\begin_inset Quotes erd
\end_inset

 classes of objects.
\end_layout

\begin_deeper
\begin_layout Itemize
Character
\end_layout

\begin_layout Itemize
Numeric (real numbers) (decimals)
\end_layout

\begin_layout Itemize
Integer
\end_layout

\begin_layout Itemize
Complex
\end_layout

\begin_layout Itemize
Logical (true/false)
\end_layout

\end_deeper
\begin_layout Itemize
The most basic object is a vector.
\end_layout

\begin_deeper
\begin_layout Itemize
A vector can only contain objects of the same class.
\end_layout

\begin_layout Itemize
A list is represented as a vector but can contain objects of different classes.
\end_layout

\end_deeper
\begin_layout Itemize
Empty vectors can be created with the vector() function.
\end_layout

\begin_deeper
\begin_layout Itemize
First argument: class of objects in vector.
\end_layout

\begin_layout Itemize
Second argument: length of vector.
\end_layout

\end_deeper
\begin_layout Itemize
Numbers
\end_layout

\begin_deeper
\begin_layout Itemize
Generally treated as double precision real numbers.
\end_layout

\begin_layout Itemize
If you explicitly want an integer, you need to specify the L suffix: 1L.
\end_layout

\begin_layout Itemize
There is also a special number Inf which represents infinity (1/0).
\end_layout

\begin_layout Itemize
The value NaN represents an undefined value.
\end_layout

\end_deeper
\begin_layout Itemize
R objects can have attributes.
\end_layout

\begin_deeper
\begin_layout Itemize
Names, dimnames
\end_layout

\begin_layout Itemize
Dimensions
\end_layout

\begin_layout Itemize
Class: numeric, character, etc.
\end_layout

\begin_layout Itemize
Length
\end_layout

\begin_layout Itemize
Other user-defined attributes/metadata.
\end_layout

\begin_layout Itemize
Attributes of an object can be accessed using the attributes() function.
\end_layout

\end_deeper
\begin_layout Subsection*
R Vectors and Lists
\end_layout

\begin_layout Itemize
The c() function can be used to create vectors of objects.
\end_layout

\begin_deeper
\begin_layout Itemize
Ex: x <- c(0.5, 0.6)
\end_layout

\begin_layout Itemize
Ex: x <- c(TRUE, FALSE)
\end_layout

\begin_layout Itemize
Ex: x <- c(
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

,
\begin_inset Quotes erd
\end_inset

b
\begin_inset Quotes erd
\end_inset

,
\begin_inset Quotes erd
\end_inset

c
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_deeper
\begin_layout Itemize
Using the vector() function:
\end_layout

\begin_deeper
\begin_layout Itemize
Example: x <- vector(
\begin_inset Quotes eld
\end_inset

numeric
\begin_inset Quotes erd
\end_inset

, length = 10) outputs a vector of 10 zeros (0 is default value).
\end_layout

\end_deeper
\begin_layout Itemize
When different objects are mixed in a vector, 
\emph on
coercion
\emph default
 occurs so that every element in the vector is of the same class.
\end_layout

\begin_deeper
\begin_layout Itemize
Ex: y <- c(1.7, 
\begin_inset Quotes erd
\end_inset

a
\begin_inset Quotes erd
\end_inset

) is a character vector, so the first element will be a string: 
\begin_inset Quotes eld
\end_inset

1.7
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Itemize
Ex: y <- c(TRUE, 2) is numeric because True/False can be represented as
 1/0.
\end_layout

\begin_layout Itemize
Ex: y <- c(
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

, TRUE) is a character vector.
\end_layout

\end_deeper
\begin_layout Itemize
Explicit coercion - use the as.* functions:
\end_layout

\begin_deeper
\begin_layout Itemize
Example: x <- 0:6 is an integer sequence, so we can do as.numeric(x), as.character
(x), as.logical(x), etc.
\end_layout

\begin_layout Itemize
Coercion doesn't always work - nonsensical coercion results in NAs and a
 warning.
\end_layout

\end_deeper
\begin_layout Itemize
Lists - a special type of vector that can contain elements of different
 classes.
\end_layout

\begin_deeper
\begin_layout Itemize
They are a VERY important data type in R.
\end_layout

\begin_layout Itemize
Example: x <- list(1, 
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

, TRUE, 1 + 4i)
\end_layout

\end_deeper
\begin_layout Subsection*
Matrices
\end_layout

\begin_layout Itemize
Matrices are vectors with a dimension attribute.
\end_layout

\begin_layout Itemize
The dimension attribute is itself an integer vector of length 2 (nrow, ncol).
\end_layout

\begin_layout Itemize
Example: m <- matrix(nrow = 2, ncol = 3)
\end_layout

\begin_deeper
\begin_layout Itemize
Can do dim(m), attributes(m) to get attributes of the matric.
\end_layout

\end_deeper
\begin_layout Itemize
Matrices are inserted column-wise: 1st column is filled, then 2nd column,
 and so on.
\end_layout

\begin_deeper
\begin_layout Itemize
Example; m <- matrix(1:6, nrow = 2, ncol = 3) has column 1 = 1, 2; column
 2 = 3, 4; column 3 = 5, 6
\end_layout

\end_deeper
\begin_layout Itemize
Matrices can be created directly from vectors by adding a dimension attribute.
\end_layout

\begin_deeper
\begin_layout Itemize
m <- 1:0
\end_layout

\begin_layout Itemize
dim(m) <- c(2,5)
\end_layout

\end_deeper
\begin_layout Itemize
Matrices can be created by column-binding or row-binding with cbind() and
 rbind()
\end_layout

\begin_deeper
\begin_layout Itemize
Example:
\end_layout

\begin_deeper
\begin_layout Itemize
x <- 1:3
\end_layout

\begin_layout Itemize
y <- 10:12
\end_layout

\begin_layout Itemize
cbind(x,y) gives a matrix with column 1 = 1,2,3 and column 2 = 10,11,12
\end_layout

\begin_layout Itemize
rbind(x,y) gives a matrix with column 1 = 1,10; column 2 = 2,11; column
 3 = 3,12
\end_layout

\end_deeper
\end_deeper
\begin_layout Subsection*
Factors
\end_layout

\begin_layout Itemize
Factors are a special type of data that are used to represent categorical
 data.
\end_layout

\begin_layout Itemize
Factors can be ordered or unordered.
 You can think of a factor as an integer vector where each integer has a
 label.
\end_layout

\begin_layout Itemize
Factors are treated specially by modeling functions like lm() and glm()
\end_layout

\begin_layout Itemize
Using factors with labels is better than using integers because factors
 are self-describing; having a variable that has values 
\begin_inset Quotes eld
\end_inset

Male
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

Female
\begin_inset Quotes erd
\end_inset

 is more descriptive than a variable that has values 1 and 2.
\end_layout

\begin_layout Itemize
Factors are created with factor().
 Example:
\end_layout

\begin_deeper
\begin_layout Itemize
x <- factor(c(
\begin_inset Quotes eld
\end_inset

yes
\begin_inset Quotes erd
\end_inset

,
\begin_inset Quotes erd
\end_inset

yes
\begin_inset Quotes erd
\end_inset

,
\begin_inset Quotes erd
\end_inset

no
\begin_inset Quotes erd
\end_inset

,
\begin_inset Quotes erd
\end_inset

yes
\begin_inset Quotes erd
\end_inset

,
\begin_inset Quotes erd
\end_inset

no
\begin_inset Quotes erd
\end_inset

))
\end_layout

\begin_layout Itemize
When you auto-print this vector, the levels are shown - levels are possible
 values in the factor.
\end_layout

\begin_layout Itemize
table(x) gives the frequency of each value.
\end_layout

\begin_layout Itemize
unclass(x) shows what is underlying the vectors (
\begin_inset Quotes eld
\end_inset

yes
\begin_inset Quotes erd
\end_inset

 is represented as 2, 
\begin_inset Quotes eld
\end_inset

no
\begin_inset Quotes erd
\end_inset

 is represented as 1)
\end_layout

\end_deeper
\begin_layout Itemize
The order of the levels can be set using the levels argument to factor().
\end_layout

\begin_deeper
\begin_layout Itemize
x <- factor(c(
\begin_inset Quotes eld
\end_inset

yes
\begin_inset Quotes erd
\end_inset

,
\begin_inset Quotes erd
\end_inset

yes
\begin_inset Quotes erd
\end_inset

,
\begin_inset Quotes erd
\end_inset

no
\begin_inset Quotes erd
\end_inset

,
\begin_inset Quotes erd
\end_inset

yes
\begin_inset Quotes erd
\end_inset

,
\begin_inset Quotes erd
\end_inset

no
\begin_inset Quotes erd
\end_inset

), levels=c(
\begin_inset Quotes eld
\end_inset

yes
\begin_inset Quotes erd
\end_inset

,
\begin_inset Quotes erd
\end_inset

no
\begin_inset Quotes erd
\end_inset

))
\end_layout

\begin_layout Itemize
This has 
\begin_inset Quotes eld
\end_inset

yes
\begin_inset Quotes erd
\end_inset

 represented by 1 and 
\begin_inset Quotes eld
\end_inset

no
\begin_inset Quotes erd
\end_inset

 represented by 2.
\end_layout

\end_deeper
\begin_layout Subsection*
Missing Values
\end_layout

\begin_layout Itemize
Missing values are denoted by NA or NaN.
\end_layout

\begin_layout Itemize
NaN is used for undefined mathematical operations, NA is used for everything
 else.
\end_layout

\begin_layout Itemize
is.na() tests objects to see if they are NA.
\end_layout

\begin_layout Itemize
is.nan() is used to test for NaN.
\end_layout

\begin_layout Itemize
NA values have a class (integer, character, etc.)
\end_layout

\begin_layout Itemize
NaN values are also NA, but the reverse is not necessarily true.
\end_layout

\begin_layout Subsection*
Data Frames
\end_layout

\begin_layout Itemize
Data frames are used to store tabular data.
\end_layout

\begin_layout Itemize
They are represented as a special type of list where every element of the
 list has to have the same length.
\end_layout

\begin_layout Itemize
Each element of the list can be thought of as a column and the length of
 each element of the list is the number of rows.
\end_layout

\begin_layout Itemize
Unlike matrices, data frames can store different classes of objects in each
 column.
\end_layout

\begin_layout Itemize
Data frames also have a special attribute called row.names.
\end_layout

\begin_layout Itemize
Data frames are usually craeted by calling read.table() or read.csv().
\end_layout

\begin_layout Itemize
Can be converted to a matrix by calling data.matrix().
\end_layout

\begin_deeper
\begin_layout Itemize
This may cause coercion if the data types are not the same!
\end_layout

\end_deeper
\begin_layout Itemize
Data frames can also be created using data.frame()
\end_layout

\begin_deeper
\begin_layout Itemize
x <- data.frame(foo = 1:4, bar = c(T,T,T,F))
\end_layout

\begin_layout Itemize
nrow(x) gives number of rows.
\end_layout

\begin_layout Itemize
ncol(x) gives number of columns.
\end_layout

\end_deeper
\begin_layout Subsection*
Data Types - The Names Attribute
\end_layout

\begin_layout Itemize
R objects can also have names, which is very useful for writing readable
 code and self-describing objects.
\end_layout

\begin_deeper
\begin_layout Itemize
x <- 1:3
\end_layout

\begin_layout Itemize
names(x) is NULL at this point.
\end_layout

\begin_layout Itemize
names(x) <- c(
\begin_inset Quotes eld
\end_inset

foo
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

bar
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

norf
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Itemize
Now auto-printing x shows the names above each element (foo, bar, norf)
\end_layout

\end_deeper
\begin_layout Itemize
List names
\end_layout

\begin_deeper
\begin_layout Itemize
x <- list(a = 1, b = 2, c = 3)
\end_layout

\end_deeper
\begin_layout Itemize
Matrix names (dimnames)
\end_layout

\begin_deeper
\begin_layout Itemize
m <- matrix(1:4, nrow = 2, ncol = 2)
\end_layout

\begin_layout Itemize
dimnames(m) < list(c(
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

,
\begin_inset Quotes erd
\end_inset

b
\begin_inset Quotes erd
\end_inset

), c(
\begin_inset Quotes eld
\end_inset

c
\begin_inset Quotes erd
\end_inset

,
\begin_inset Quotes erd
\end_inset

d
\begin_inset Quotes erd
\end_inset

)) (this labels the rows as 
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

b
\begin_inset Quotes erd
\end_inset

 and the columns as 
\begin_inset Quotes eld
\end_inset

c
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

d
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_deeper
\begin_layout Subsection*
Reading Data Into R
\end_layout

\begin_layout Itemize
read.table(), read.csv() for reading tabular data.
\end_layout

\begin_layout Itemize
readLines() for reading lines of a text file.
\end_layout

\begin_layout Itemize
source() for reading in R code files (inverse of dump()).
\end_layout

\begin_layout Itemize
dget() for reading in R code files (inverse of dput()).
\end_layout

\begin_layout Itemize
load() for reading in saved workspaces.
\end_layout

\begin_layout Itemize
read.table() arguments:
\end_layout

\begin_deeper
\begin_layout Itemize
file - name of file, or a connection.
\end_layout

\begin_layout Itemize
header - logical indicating if the first line of the file is a header line.
\end_layout

\begin_layout Itemize
sep - a string indicated how the columns are separated.
\end_layout

\begin_layout Itemize
colClasses - a character vector indicating the class of each column in the
 dataset.
\end_layout

\begin_layout Itemize
nrows - the number of rows in the dataset.
\end_layout

\begin_layout Itemize
comment.char - a character string indicating the comment character.
\end_layout

\begin_layout Itemize
skip - the number of lines to skip from the beginning.
\end_layout

\begin_layout Itemize
stringsAsFactors - should character variables be coded as factors?
\end_layout

\end_deeper
\begin_layout Itemize
For small to moderate sized datasets, you can usually call read.table() without
 specifying any other arguments:
\end_layout

\begin_deeper
\begin_layout Itemize
data <- read.table(
\begin_inset Quotes eld
\end_inset

foo.txt
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Itemize
R will automatically skip lines that begin with #, figure out how many rows
 there and how much memory to allocate, and figure out variable types.
\end_layout

\begin_layout Itemize
It may run faster if you provide other information.
\end_layout

\begin_layout Itemize
read.csv() is the same except it assumes the separator value is a comma (instead
 of a space).
\end_layout

\end_deeper
\begin_layout Subsection*
Reading Large Tables
\end_layout

\begin_layout Itemize
Some things you can do to make your life easier and prevent R from choking
 when you use large datasets.
\end_layout

\begin_deeper
\begin_layout Itemize
Read the help page for read.table, which contains many hints.
\end_layout

\begin_layout Itemize
Make a rough calculation of the memory required to store your dataset.
\end_layout

\begin_layout Itemize
Set comment.char = 
\begin_inset Quotes eld
\end_inset


\begin_inset Quotes erd
\end_inset

 if there are no commented lines in your file.
\end_layout

\begin_layout Itemize
Use the colClasses argument.
\end_layout

\begin_deeper
\begin_layout Itemize
Specifying this option instead of using the default can make read.table run
 twice as fast!
\end_layout

\begin_layout Itemize
If you only specify a single value for colClasses, it assumes all columns
 are this class.
\end_layout

\begin_layout Itemize
A quick and dirty way to figure out column classes:
\end_layout

\begin_deeper
\begin_layout Itemize
initial <- read.table(
\begin_inset Quotes eld
\end_inset

datatable.txt
\begin_inset Quotes erd
\end_inset

, nrows = 100)
\end_layout

\begin_layout Itemize
classes <- sapply(initial,class)
\end_layout

\begin_layout Itemize
tabAll <- read.table(
\begin_inset Quotes eld
\end_inset

datatable.txt
\begin_inset Quotes erd
\end_inset

, colClasses = classes)
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Setting nrows doesn't make it run faster but does help with memory usage.
\end_layout

\end_deeper
\begin_layout Itemize
Should know the following about your system:
\end_layout

\begin_deeper
\begin_layout Itemize
RAM in your computer.
\end_layout

\begin_layout Itemize
What other applications are in use?
\end_layout

\begin_layout Itemize
What OS?
\end_layout

\begin_layout Itemize
Is the OS 32 or 64-bit?
\end_layout

\begin_layout Itemize
Are there other users logged into the same system?
\end_layout

\end_deeper
\begin_layout Itemize
Roughly calculating memory requirements
\end_layout

\begin_deeper
\begin_layout Itemize
Example: data frame with 1500000 rows and 120 columns, all of which are
 numeric data.
\end_layout

\begin_layout Itemize
1500000*120*8 bytes/numeric = 1440000000 bytes = 1440000000/2^20 bytes/MB
 = 1373.29 MB
\end_layout

\begin_layout Itemize
Will need some overhead for reading in this data - probably about a factor
 of 2.
\end_layout

\end_deeper
\begin_layout Subsection*
Textual Data Formats
\end_layout

\begin_layout Itemize
dump and dput are useful because the resulting textual format is editable,
 and may be possible to recover if corrupted.
\end_layout

\begin_layout Itemize
Unlike writing out a table or csv file, dump and dput preserve the metadata
 so that another user won't have to specify it all over again.
\end_layout

\begin_layout Itemize
Textual formats can work much better with version control programs which
 can only track changes meaningfully in text files.
\end_layout

\begin_layout Itemize
Downside: textual files are not very space-efficient.
 One option is to compress them.
\end_layout

\begin_layout Itemize
dput-ing R objects: provides a way to write R code that can be used to reconstru
ct an R object.
\end_layout

\begin_deeper
\begin_layout Itemize
y <- data.frame(a = 1, b = 
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Itemize
dput(y) gives: structure(list(a=1, b=structure(1L, .Label = 
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

, class = 
\begin_inset Quotes eld
\end_inset

factor
\begin_inset Quotes erd
\end_inset

)), .Names = c(
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

,
\begin_inset Quotes erd
\end_inset

b
\begin_inset Quotes erd
\end_inset

), row.names = c(NA, -1L), class = 
\begin_inset Quotes eld
\end_inset

data.frame
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Itemize
dput(y, file = 
\begin_inset Quotes eld
\end_inset

y.r
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Itemize
new.y <- dget(
\begin_inset Quotes eld
\end_inset

y.R
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_deeper
\begin_layout Itemize
dump can be used on multiple R objects, unlike dput.
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
y <- data.frame(a=1,b=
\begin_inset Quotes erd
\end_inset

a
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Itemize

\family typewriter
dump(c(
\begin_inset Quotes eld
\end_inset

x
\begin_inset Quotes erd
\end_inset

,
\begin_inset Quotes erd
\end_inset

y
\begin_inset Quotes erd
\end_inset

), file = 
\begin_inset Quotes eld
\end_inset

data.R
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Itemize

\family typewriter
rm(x,y)
\end_layout

\begin_layout Itemize

\family typewriter
source(
\begin_inset Quotes eld
\end_inset

data.R
\begin_inset Quotes erd
\end_inset

)
\family default
 to get x and y from the file.
\end_layout

\end_deeper
\begin_layout Subsection*
Connections - Interfaces to the Outside World
\end_layout

\begin_layout Itemize
Data are read in using connection interfaces.
\end_layout

\begin_layout Itemize
Connections can be made to files (most common) or to other things.
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
file
\family default
 - opens a connection to a file.
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
con <- file(
\begin_inset Quotes eld
\end_inset

foo.txt
\begin_inset Quotes erd
\end_inset

,
\begin_inset Quotes erd
\end_inset

r
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Itemize

\family typewriter
data <- read.csv(con)
\end_layout

\begin_layout Itemize

\family typewriter
close(con)
\end_layout

\end_deeper
\begin_layout Itemize

\family typewriter
gzfile
\family default
 - opens a connection to a file compressed with gzip.
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
con <- gzfiles(
\begin_inset Quotes eld
\end_inset

words.gz
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Itemize

\family typewriter
x <- readLines(con, 10)
\end_layout

\end_deeper
\begin_layout Itemize

\family typewriter
bzfile
\family default
 - opens a connection to a file compressed with bzip2.
\end_layout

\begin_layout Itemize

\family typewriter
url
\family default
 - opens a connection to a webpage.
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
con <- url(
\begin_inset Quotes eld
\end_inset

http://ww.jhsph.edu
\begin_inset Quotes erd
\end_inset

,
\begin_inset Quotes erd
\end_inset

r
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Itemize

\family typewriter
x <- readLines(con)
\end_layout

\end_deeper
\end_deeper
\begin_layout Subsection*
Subsetting R Objects
\end_layout

\begin_layout Itemize
Several operators for extracting subsets in R.
\end_layout

\begin_deeper
\begin_layout Itemize
[ - returns a subset of the same class as the original; can be used to select
 more than one element (with one exception).
\end_layout

\begin_layout Itemize
[[ - is used to extract elements of a list or data frame and can only be
 used to extract a single element.
 The class of the returned object will not necessarily be a list or data
 frame.
\end_layout

\begin_layout Itemize
$ - is used to extract elements of a list or data frame by name; semantics
 are similar to that of [[.
\end_layout

\end_deeper
\begin_layout Itemize
Example:
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
x <- c(
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

,
\begin_inset Quotes erd
\end_inset

b
\begin_inset Quotes erd
\end_inset

,
\begin_inset Quotes erd
\end_inset

c
\begin_inset Quotes erd
\end_inset

,
\begin_inset Quotes erd
\end_inset

c
\begin_inset Quotes erd
\end_inset

,
\begin_inset Quotes erd
\end_inset

d
\begin_inset Quotes erd
\end_inset

,
\begin_inset Quotes erd
\end_inset

a
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Itemize

\family typewriter
x[1]
\family default
 returns 
\family typewriter

\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize

\family typewriter
x[1:4]
\family default
 returns 
\family typewriter

\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

 
\begin_inset Quotes eld
\end_inset

b
\begin_inset Quotes erd
\end_inset

 
\begin_inset Quotes eld
\end_inset

c
\begin_inset Quotes erd
\end_inset

 
\begin_inset Quotes eld
\end_inset

c
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize

\family typewriter
x[x > 
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

]
\family default
 returns 
\family typewriter

\begin_inset Quotes eld
\end_inset

b
\begin_inset Quotes erd
\end_inset

 
\begin_inset Quotes eld
\end_inset

c
\begin_inset Quotes erd
\end_inset

 
\begin_inset Quotes eld
\end_inset

c
\begin_inset Quotes erd
\end_inset

 
\begin_inset Quotes eld
\end_inset

d
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize

\family typewriter
u <- x > 
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset


\family default
 returns 
\family typewriter
FALSE TRUE TRUE TRUE TRUE FALSE
\end_layout

\end_deeper
\begin_layout Itemize
Subsetting lists is a little different because you can use any of the 3
 operators.
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
x <- list(foo = 1:4, bar = 0.6)
\end_layout

\begin_layout Itemize

\family typewriter
x[1]
\family default
 returns 
\family typewriter
$foo
\family default
 and 
\family typewriter
1 2 3 4
\family default
 (i.e., a list)
\end_layout

\begin_layout Itemize

\family typewriter
x[[1]]
\family default
 returns 
\family typewriter
1 2 3 4
\family default
 (i.e., just a sequence)
\end_layout

\begin_layout Itemize

\family typewriter
x$bar
\family default
 or 
\family typewriter
x[[
\begin_inset Quotes eld
\end_inset

bar
\begin_inset Quotes erd
\end_inset

]]
\family default
 returns 
\family typewriter
0.6
\end_layout

\begin_layout Itemize

\family typewriter
x[
\begin_inset Quotes eld
\end_inset

bar
\begin_inset Quotes erd
\end_inset

]
\family default
 returns 
\family typewriter
$bar
\family default
 and 
\family typewriter
0.6
\end_layout

\end_deeper
\begin_layout Itemize
To extract multiple elements of a list, use the single bracket operator
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
x <- list(foo = 1:4, bar = 0.6, baz = 
\begin_inset Quotes eld
\end_inset

hello
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Itemize

\family typewriter
x[c(1,3)]
\family default
 return 
\family typewriter
$foo 1 2 3 4
\family default
 and 
\family typewriter
$baz 
\begin_inset Quotes eld
\end_inset

hello
\begin_inset Quotes erd
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
The [[ operator can be used with string variables where the name of the
 element is computed.
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
name <- 
\begin_inset Quotes eld
\end_inset

foo
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize

\family typewriter
x[[name]]
\family default
 returns 
\family typewriter
1 2 3 4
\end_layout

\end_deeper
\begin_layout Itemize
Subsetting nested elements of a list
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
x <- list(a = list(10,12,14), b = c(3.14,2.81))
\end_layout

\begin_layout Itemize

\family typewriter
x[[c(1,3))]]
\family default
 returns 
\family typewriter
14
\end_layout

\begin_layout Itemize

\family typewriter
x[[1]][[3]]
\family default
 returns 
\family typewriter
14
\end_layout

\begin_layout Itemize

\family typewriter
x[[c(2,1)]]
\family default
 returns 
\family typewriter
3.14
\end_layout

\end_deeper
\begin_layout Itemize
Subsetting matrices - can use (i,j) type indices
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
x <- matrix(1:6, 2, 3)
\end_layout

\begin_layout Itemize

\family typewriter
x[1, 2]
\family default
 returns 
\family typewriter
3
\end_layout

\begin_layout Itemize

\family typewriter
x[2, 1]
\family default
 returns 
\family typewriter
2
\end_layout

\end_deeper
\begin_layout Itemize
Matrix indices can also be missing:
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
x[1, ]
\family default
 returns first row: 
\family typewriter
1 3 5
\end_layout

\end_deeper
\begin_layout Itemize
By default, when a single element of a matrix is retrieved, it is returned
 as a vector of length 1 rather than a 1 x 1 matrix.
 Use 
\family typewriter
drop = FALSE
\family default
 to turn this behavior off.
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
x[1, 2, drop = FALSE]
\family default
 returns 
\family typewriter
3
\family default
 as a matrix.
\end_layout

\end_deeper
\begin_layout Itemize
Subsetting a single column or row gives a vector by default, too.
 Can use 
\family typewriter
drop = FALSE
\family default
 again here.
\end_layout

\begin_layout Itemize
Partial matching of names is allowed with [[ and $.
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
x <- list (aardvark = 1:5)
\end_layout

\begin_layout Itemize

\family typewriter
x$a
\family default
 returns 
\family typewriter
1 2 3 4 5
\end_layout

\begin_layout Itemize

\family typewriter
x[[
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

]] returns NULL
\end_layout

\begin_layout Itemize

\family typewriter
x[[
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

, exact = FALSE]]
\family default
 returns 
\family typewriter
1 2 3 4 5
\end_layout

\end_deeper
\begin_layout Subsection*
Removing NA Values
\end_layout

\begin_layout Itemize
Example:
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
x <- c(1,2,NA,4,NA,5)
\end_layout

\begin_layout Itemize

\family typewriter
bad <- is.na(x)
\end_layout

\begin_layout Itemize

\family typewriter
x[!bad]
\family default
 returns 
\family typewriter
1 2 4 5
\end_layout

\begin_layout Itemize
Note: exclamation point is NOT operator.
\end_layout

\end_deeper
\begin_layout Itemize
Finding subset of multiple things with no missing values:
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
x <- c(1,2,NA,4,NA,5)
\end_layout

\begin_layout Itemize

\family typewriter
y <- c(
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

,
\begin_inset Quotes erd
\end_inset

b
\begin_inset Quotes erd
\end_inset

,NA,
\begin_inset Quotes erd
\end_inset

d
\begin_inset Quotes erd
\end_inset

,NA,
\begin_inset Quotes erd
\end_inset

f
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Itemize

\family typewriter
good <- complete.cases(x,y)
\end_layout

\begin_layout Itemize

\family typewriter
good
\family default
 returns 
\family typewriter
TRUE TRUE FALSE TRUE FALSE TRUE
\end_layout

\begin_layout Itemize

\family typewriter
x[good]
\family default
 gives 
\family typewriter
1 2 4 5
\end_layout

\begin_layout Itemize

\family typewriter
y[good]
\family default
 gives 
\family typewriter

\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

 
\begin_inset Quotes eld
\end_inset

b
\begin_inset Quotes erd
\end_inset

 
\begin_inset Quotes eld
\end_inset

d
\begin_inset Quotes erd
\end_inset

 
\begin_inset Quotes eld
\end_inset

f
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Can use this to get only good rows or columns in a data file.
\end_layout

\end_deeper
\begin_layout Subsection*
Vectorized Operations
\end_layout

\begin_layout Itemize
Can do operations on array elements in parallel (just like in Matlab).
\end_layout

\begin_layout Itemize
Can do this on matrices as well.
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
x * y
\family default
 is element-wise multiplication.
\end_layout

\begin_layout Itemize

\family typewriter
x %*% y
\family default
 is true matrix multiplication.
\end_layout

\end_deeper
\begin_layout Subsection*
Control Structures - If, Else
\end_layout

\begin_layout Itemize
Basic structure:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

if (<condition1>) {
\end_layout

\begin_layout Plain Layout

	## do something
\end_layout

\begin_layout Plain Layout

} else if (<condition2>){
\end_layout

\begin_layout Plain Layout

	## do something
\end_layout

\begin_layout Plain Layout

} else {
\end_layout

\begin_layout Plain Layout

	## do something
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Can assign value:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

y <- if (<condition1>) {
\end_layout

\begin_layout Plain Layout

	10
\end_layout

\begin_layout Plain Layout

} else {
\end_layout

\begin_layout Plain Layout

	0
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Control Structures - For Loops
\end_layout

\begin_layout Itemize
Example:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for (i in 1:10){
\end_layout

\begin_layout Plain Layout

	print(i)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Example 2: all of these for loops are equivalent.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

x <- c("a","b","c","d")
\end_layout

\begin_layout Plain Layout

for (i in 1:4){
\end_layout

\begin_layout Plain Layout

	print(x[i])
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

for (i in seq_along(x)){
\end_layout

\begin_layout Plain Layout

	print(x[i])
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

for (letter in x){
\end_layout

\begin_layout Plain Layout

	print(letter)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Can nest for loops - example: loop over elements in a matrix.
\end_layout

\begin_layout Subsection*
Control Structures - While Loops
\end_layout

\begin_layout Itemize
Example:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

count <- 0
\end_layout

\begin_layout Plain Layout

while (count < 10 {
\end_layout

\begin_layout Plain Layout

	print(count)
\end_layout

\begin_layout Plain Layout

	cout <- count + 1
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Control Structures - Repeat, Next, Break
\end_layout

\begin_layout Itemize

\family typewriter
repeat
\family default
 initiates an infinite loop - these are not common but do have their uses.
 The only way to exit is to call 
\family typewriter
break
\family default
.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

x0 <- 1
\end_layout

\begin_layout Plain Layout

tol <- 1e-8
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

repeat {
\end_layout

\begin_layout Plain Layout

	x1 <- computeEstimate()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	if (abs(x1-x0) < tol) {
\end_layout

\begin_layout Plain Layout

		break
\end_layout

\begin_layout Plain Layout

	} else {
\end_layout

\begin_layout Plain Layout

		x0 <- x1
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
This is dangerous because there is no guarantee that the loop will converge.
\end_layout

\begin_layout Itemize
It's better to set a hard limit on the number of iterations and then report
 whether convergence was achieved or not.
\end_layout

\begin_layout Itemize

\family typewriter
next
\family default
 is used to skip an iteration of a loop.
\end_layout

\begin_layout Itemize

\family typewriter
return
\family default
 signals that a function should exit and return a given value.
 This can also be used to interrupt the flow of a program.
\end_layout

\begin_layout Subsection*
R Functions
\end_layout

\begin_layout Itemize
Example of function syntax:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

add2 <- function(x,y=5) {
\end_layout

\begin_layout Plain Layout

	x + y
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\family typewriter
y=5
\family default
 assigns a default value to 
\family typewriter
y
\family default
 in case the user doesn't specify 
\family typewriter
y
\family default
.
\end_layout

\begin_layout Itemize
Don't need a return statement - all functions return the value of the last
 expression.
\end_layout

\begin_layout Itemize
Functions are R objects of class 
\begin_inset Quotes eld
\end_inset

function.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Use the function directive to define a function: 
\family typewriter
f <- function(<arguments) { ## do stuff }
\end_layout

\begin_layout Itemize
Functions can be passed as arguments to other functions.
\end_layout

\begin_layout Itemize
Functions can be nested (defined inside of another function).
\end_layout

\begin_layout Itemize
Named arguments:
\end_layout

\begin_deeper
\begin_layout Itemize
May potentially have default values.
\end_layout

\begin_layout Itemize

\emph on
Formal
\emph default
 arguments are the arguments included in the function definition.
\end_layout

\begin_layout Itemize

\family typewriter
formals
\family default
 returns a list of all formal arguments of a function.
\end_layout

\end_deeper
\begin_layout Itemize
R function arguments can be matched positionally, or by name:
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
sd(x = mydata, na.rm = FALSE)
\family default
 is the same as 
\family typewriter
sd(na.rm = FALSE, x = mydata)
\end_layout

\begin_layout Itemize
You can mix positional matching and matching by name.
 When are argument is matched by name, it is 
\begin_inset Quotes eld
\end_inset

taken out
\begin_inset Quotes erd
\end_inset

 of the argument list and the remaining unnamed arguments are matched in
 the order that they are listed in the function definition.
\end_layout

\begin_layout Itemize
Named arguments are useful on the command line when you have a long argument
 list and you want to mostly use defaults for everything except an argument
 near the end of the list, or if you can remember the name of the argument
 but not its position.
\end_layout

\end_deeper
\begin_layout Itemize
Function arguments can also be partially matched (useful if you don't remember
 the argument's exact name).
\end_layout

\begin_layout Subsection*
Defining a Function
\end_layout

\begin_layout Itemize
Function arguments can be set to 
\family typewriter
NULL
\family default
 by default.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

f <- function(a, b=1, c=2, d=NULL) {
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Arguments to function are evaluated 
\emph on
lazily
\emph default
, so they are only evaluated when they are needed:
\end_layout

\begin_layout Itemize
Example: you can call this function with 
\family typewriter
f(2)
\family default
; b is not needed since it's never used and the 2 gets positionally matched
 to a.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

f <- function(a, b) {
\end_layout

\begin_layout Plain Layout

	a^2
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
This also means that if an argument is missing, the code actually executes
 every line up until that argument is needed.
\end_layout

\begin_layout Itemize
The 
\family typewriter

\begin_inset Quotes eld
\end_inset

...
\begin_inset Quotes erd
\end_inset


\family default
 argument is used to indicate a variable number of arguments.
\end_layout

\begin_deeper
\begin_layout Itemize
Useful when you extend another function and you don't want to copy the entire
 argument list of the original function.
\end_layout

\begin_layout Itemize
Example:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

f <- function(x, y, type = "1", ...) {
\end_layout

\begin_layout Plain Layout

	plot(x, y, type = type, ...)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
This argument is also necessary when the number of arguments passed to the
 function cannot be known in advance.
\end_layout

\begin_deeper
\begin_layout Itemize
For example, the 
\family typewriter
paste
\family default
 function can take as many arguments as needed.
 If you were to extend this function, the 
\family typewriter

\begin_inset Quotes eld
\end_inset

...
\begin_inset Quotes erd
\end_inset


\family default
 operator would be useful.
\end_layout

\end_deeper
\begin_layout Itemize
One catch: any arguments in the argument list must be named explicitly and
 cannot be partially matched.
\end_layout

\end_deeper
\begin_layout Subsection*
Symbol Binding
\end_layout

\begin_layout Itemize
When R tries to bind a value to a symbol, it looks through the global environmen
t and the packages in the search list.
\end_layout

\begin_layout Itemize
The order of packages in the search list matters!
\end_layout

\begin_layout Itemize
Users can configure which packages get loaded on startup.
\end_layout

\begin_layout Itemize
When a user loads a package with 
\family typewriter
library
\family default
, the namespace of that package gets put in position 2 on the search list
 and everything else gets shifted down.
\end_layout

\begin_layout Itemize
R has separate namespaces for functions and non-functions, so it's possible
 to have an object and function with the same name.
\end_layout

\begin_layout Itemize
Scoping rules determine how a value is associated with a free variable in
 a function.
\end_layout

\begin_deeper
\begin_layout Itemize
R uses 
\emph on
lexical
\emph default
 or 
\emph on
static
\emph default
 scoping.
\end_layout

\begin_deeper
\begin_layout Itemize
Example:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

f <- function(x, y) {
\end_layout

\begin_layout Plain Layout

	x^2 + y/z
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Here z is not a formal argument or a local variable - it's called a 
\emph on
free variable
\emph default
.
\end_layout

\begin_layout Itemize
Lexical scoping means that the values of free variables are searched for
 in the environment in which the function was defined.
\end_layout

\begin_layout Itemize
If the value of a symbol is not found in this environment, the search is
 continued in the parent environment.
\end_layout

\begin_layout Itemize
The search continues down the sequence of parent environments until we hit
 the top-level environment; this is usually the global environment (workspace)
 or the namespace of a package.
\end_layout

\begin_layout Itemize
After the top-level environment, the search continues down the search list
 until we hit the empty environment.
\end_layout

\begin_layout Itemize
If a value for a given symbol cannot be found once the empty environment
 is arrived at, an error is thrown.
\end_layout

\end_deeper
\begin_layout Itemize
Typically a function is defined in the global environment so the values
 of free variables are just found in the user's workspace.
\end_layout

\begin_layout Itemize
But in R, you can have functions defined inside other functions - in this
 case the environment in which the function is defined is the body of another
 function.
\end_layout

\begin_deeper
\begin_layout Itemize
You can use this to define a function which constructs other functions.
\end_layout

\end_deeper
\begin_layout Itemize
What's in a function's environment?
\end_layout

\begin_deeper
\begin_layout Itemize
Can use 
\family typewriter
ls(environment(function))
\family default
 to get this.
\end_layout

\end_deeper
\begin_layout Itemize
In R, all objects must be stored in memory.
\end_layout

\begin_deeper
\begin_layout Itemize
All functions must carry a pointer to their respective defining environments,
 which could be anywhere.
\end_layout

\end_deeper
\begin_layout Subsection*
Optimization
\end_layout

\begin_layout Itemize
Some optimization routines: 
\family typewriter
optim, nlm, optimize
\family default
.
\end_layout

\begin_layout Itemize
May be useful to hold some parameters fixed and allow other to vary during
 the optimization.
\end_layout

\begin_layout Itemize
Useful solution - write a 
\begin_inset Quotes eld
\end_inset

constructor
\begin_inset Quotes erd
\end_inset

 function which contains all of the necessary data for evaluating the function.
\end_layout

\begin_layout Subsection*
Coding Standards in R
\end_layout

\begin_layout Itemize
Write code in a text file with a text editor.
\end_layout

\begin_layout Itemize
Indent your code to keep the flow of the program and different control blocks
 easily readable.
\end_layout

\begin_deeper
\begin_layout Itemize
Suggested to set TAB to be 4 - 8 spaces.
\end_layout

\end_deeper
\begin_layout Itemize
Limit the width of your code (80 columns?)
\end_layout

\begin_layout Itemize
Limit the length of your functions.
\end_layout

\begin_layout Subsection*
Dates and Times in R
\end_layout

\begin_layout Itemize
R has a special representation for dates and times.
\end_layout

\begin_deeper
\begin_layout Itemize
Dates are represented by the 
\family typewriter
Date
\family default
 class.
\end_layout

\begin_layout Itemize
Times are represented by the 
\family typewriter
POSIXct
\family default
 or the 
\family typewriter
POSIXlt
\family default
 class.
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
POSIXct
\family default
 is just a very large integer under the hood
\end_layout

\begin_layout Itemize

\family typewriter
POSIXlt
\family default
 is a list underneath and stores a bunch of other useful information like
 the day of the week, day of the year, month, day of the month, etc.
\end_layout

\end_deeper
\begin_layout Itemize
Dates are stored internally as the number of days since 1/1/1970.
\end_layout

\begin_layout Itemize
Times are stored internally as the number of seconds since 1/1/1970.
\end_layout

\end_deeper
\begin_layout Itemize
Date example:
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
x <- as.Date(
\begin_inset Quotes eld
\end_inset

1970-01-01
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Itemize

\family typewriter
unclass(x)
\family default
 returns 0.
\end_layout

\end_deeper
\begin_layout Itemize
There are a number of generic functions that work on dates and times.
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
weekdays
\family default
: gives day of the week
\end_layout

\begin_layout Itemize

\family typewriter
months
\family default
: gives the month name
\end_layout

\end_deeper
\begin_layout Itemize
Time example:
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
x <- Sys.time()
\end_layout

\begin_layout Itemize

\family typewriter
p <- as.POSIXlt(x)
\end_layout

\begin_layout Itemize

\family typewriter
names(unclass(p))
\family default
 returns 
\family typewriter

\begin_inset Quotes eld
\end_inset

sec
\begin_inset Quotes erd
\end_inset

 
\begin_inset Quotes eld
\end_inset

min
\begin_inset Quotes erd
\end_inset

 
\begin_inset Quotes eld
\end_inset

hour
\begin_inset Quotes erd
\end_inset

 
\begin_inset Quotes eld
\end_inset

mday
\begin_inset Quotes erd
\end_inset

 
\begin_inset Quotes eld
\end_inset

mon
\begin_inset Quotes erd
\end_inset

 
\begin_inset Quotes eld
\end_inset

year
\begin_inset Quotes erd
\end_inset

 
\begin_inset Quotes eld
\end_inset

wday
\begin_inset Quotes erd
\end_inset

 
\begin_inset Quotes eld
\end_inset

yday
\begin_inset Quotes erd
\end_inset

 
\begin_inset Quotes eld
\end_inset

isdst
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize

\family typewriter
c <- as.POSIXct(x)
\family default
 gives 
\family typewriter

\begin_inset Quotes eld
\end_inset

Already in 'POSIXct format
\begin_inset Quotes erd
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\family typewriter
strptime
\family default
 can convert from string to a Date or Time object (just like in Python).
\end_layout

\begin_deeper
\begin_layout Itemize
Check 
\family typewriter
?strptime
\family default
 to get the formatting strings.
\end_layout

\end_deeper
\begin_layout Itemize
You can use + and - on dates and times.
\end_layout

\begin_layout Itemize
You can use comparison operators, too.
\end_layout

\begin_layout Itemize
Can't always mix different objects (need to convert between classes before
 performing operations).
\end_layout

\begin_layout Itemize
Even keeps track of leap years, leap seconds, daylight savings, and time
 zones.
\end_layout

\begin_layout Subsection*
Loop functions - lapply
\end_layout

\begin_layout Itemize

\family typewriter
lapply
\family default
 loops over a list and evaluates a function on each element.
\end_layout

\begin_layout Itemize

\family typewriter
sapply
\family default
 is the same as lapply, but tries to simplify the result.
\end_layout

\begin_layout Itemize
lapply takes three arguments:
\end_layout

\begin_deeper
\begin_layout Itemize
A list 
\family typewriter
x.
\end_layout

\begin_layout Itemize
A function or the name of a function.
\end_layout

\begin_layout Itemize
Other arguments using the ...
 argument.
\end_layout

\end_deeper
\begin_layout Itemize
The looping is done internally in C code.
\end_layout

\begin_layout Itemize

\family typewriter
lapply
\family default
 always returns a list, regardless of the input class
\end_layout

\begin_layout Itemize
Example:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

x <- list(a=1:5, b=rnorm(10))
\end_layout

\begin_layout Plain Layout

lapply(x,mean)
\end_layout

\begin_layout Plain Layout

$a
\end_layout

\begin_layout Plain Layout

[1] 3
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

$b
\end_layout

\begin_layout Plain Layout

[1] 0.0296824
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Example 2:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

x <- 1:3
\end_layout

\begin_layout Plain Layout

lapply(x,runif,min=0,max=10)
\end_layout

\begin_layout Plain Layout

[[1]]
\end_layout

\begin_layout Plain Layout

[1] 3.302142
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[2]]
\end_layout

\begin_layout Plain Layout

[1] 6.848960 7.195282
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[3]]
\end_layout

\begin_layout Plain Layout

[1] 3.5031416 0.8465707 9.7421014
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\family typewriter
lapply
\family default
 and friends make heavy use of 
\emph on
anonymous
\emph default
 functions.
\end_layout

\begin_deeper
\begin_layout Itemize
Example:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

x <- 1:4
\end_layout

\begin_layout Plain Layout

lapply(x, function(elt) elt[,1])
\end_layout

\begin_layout Plain Layout

$a
\end_layout

\begin_layout Plain Layout

[1] 1 2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

$b
\end_layout

\begin_layout Plain Layout

[1] 1 2 3
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\family typewriter
sapply
\family default
 simplifications.
\end_layout

\begin_deeper
\begin_layout Itemize
If the result is a list where every element is length 1, it returns a vector.
\end_layout

\begin_layout Itemize
If the result is a list where every element is a vector of the same length
 (>1), a matrix is returned.
\end_layout

\begin_layout Itemize
If it can't figure things out, a list is returned.
\end_layout

\end_deeper
\begin_layout Subsection*
Loop functions - apply
\end_layout

\begin_layout Itemize

\family typewriter
apply
\family default
 applies a function over the margins of an array.
\end_layout

\begin_layout Itemize
It is most ofter used to apply a function to the rows of columns of a matrix.
\end_layout

\begin_layout Itemize
It can be used with general arrays (e.g., taking the average of an array of
 matrices).
\end_layout

\begin_layout Itemize
It is not really faster than writing a loop, but works in a single line.
\end_layout

\begin_layout Itemize
Arguments:
\end_layout

\begin_deeper
\begin_layout Itemize
An array 
\family typewriter
x
\family default
 (recall that an array is a vector with dimensions attached to it).
\end_layout

\begin_layout Itemize
An integer vector 
\family typewriter
margin
\family default
 indicating which margins should be 
\begin_inset Quotes eld
\end_inset

retained
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Itemize
Using 
\family typewriter
margin
\family default
 = 2 will keep dimension 2 (i.e.
 it will apply the function over each column).
\end_layout

\end_deeper
\begin_layout Itemize
A function 
\family typewriter
fun
\family default
 to be applied.
\end_layout

\begin_layout Itemize
...
 other arguments.
\end_layout

\end_deeper
\begin_layout Itemize
Shortcut functions - highly optimized to do special operations quickly.
 Faster than actually calling apply.
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
rowSums = apply(x,1,sum)
\end_layout

\begin_layout Itemize

\family typewriter
rowMeans = apply(x,1,mean)
\end_layout

\begin_layout Itemize

\family typewriter
colSums = apply(x,2,sum)
\end_layout

\begin_layout Itemize

\family typewriter
colMeans = apply(x,2,mean)
\end_layout

\end_deeper
\begin_layout Subsection*
Loop functions - mapply
\end_layout

\begin_layout Itemize

\family typewriter
mapply
\family default
 is the multivariate version of 
\family typewriter
lapply
\family default
.
\end_layout

\begin_layout Itemize
Arguments:
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
fun
\family default
 - function to apply.
\end_layout

\begin_layout Itemize
...
 - arguments to apply over.
\end_layout

\begin_layout Itemize

\family typewriter
MoreArgs
\family default
 - list of other arguments to 
\family typewriter
fun
\family default
.
\end_layout

\begin_layout Itemize

\family typewriter
Simplify
\family default
 - indicates whether the result should be simplified.
\end_layout

\end_deeper
\begin_layout Itemize
Example: the following two lines are equivalent.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

list(rep(1,4), rep(2,3), rep(3,2), rep(4,1))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

mapply(rep, 1:4, 4:1)
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\family typewriter
mapply
\family default
 can be used to vectorize a function (i.e., allow vector inputs to functions
 that don't normally allow it).
\end_layout

\begin_layout Subsection*
Loop functions - tapply
\end_layout

\begin_layout Itemize

\family typewriter
tapply
\family default
 (
\begin_inset Quotes eld
\end_inset

table apply
\begin_inset Quotes erd
\end_inset

) applies a function over subsets of a vector.
\end_layout

\begin_layout Itemize
Arguments:
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
x
\family default
 is a vector.
\end_layout

\begin_layout Itemize

\family typewriter
Index
\family default
 is a factor or a list of factors.
\end_layout

\begin_layout Itemize

\family typewriter
fun
\family default
 is a function to be applied.
\end_layout

\begin_layout Itemize
...
 contains other arguments to be passed to 
\family typewriter
fun
\family default
.
\end_layout

\begin_layout Itemize

\family typewriter
simplify
\family default
 specifies if we should simplify the result.
\end_layout

\end_deeper
\begin_layout Itemize
Uses factor variables to split the input vector into groups.
\end_layout

\begin_layout Subsection*
Loop functions - split
\end_layout

\begin_layout Itemize

\family typewriter
split
\family default
 is not technically a loop function, but rather an auxiliary function that
 is typically used in conjunction with loop functions.
\end_layout

\begin_layout Itemize
It takes a vector or other obejct and splits it into gropus determined by
 a factor or list of factor.
\end_layout

\begin_layout Itemize
Arguments:
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
x
\family default
 is a vector or list or data frame.
\end_layout

\begin_layout Itemize

\family typewriter
f
\family default
 is a factor (or coerced to one) or a list of factors.
\end_layout

\begin_layout Itemize

\family typewriter
drop
\family default
 indicates whether empty levels should be dropped.
\end_layout

\end_deeper
\begin_layout Itemize
Can use 
\family typewriter
gl
\family default
 function to define factors.
\end_layout

\begin_layout Itemize
In some cases, using 
\family typewriter
split
\family default
 then 
\family typewriter
lapply
\family default
 can be equivalent to doing 
\family typewriter
tapply
\family default
.
 But the first method is more flexible in general.
\end_layout

\begin_layout Itemize
Example with data from Programming Assignment #1:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

s <- split(airquality, airquality$Month
\end_layout

\begin_layout Plain Layout

## above we use the month as a factor variable
\end_layout

\begin_layout Plain Layout

## even though it isn't one technically
\end_layout

\begin_layout Plain Layout

lapply(s, function(x) colMeans(x[, c("Ozone", "Solar.R", "Wind")],
\end_layout

\begin_layout Plain Layout

	   na.rm = TRUE))
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Splitting on more than one level:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

x <- rnorm(10)
\end_layout

\begin_layout Plain Layout

f1 <- gl(2,5)
\end_layout

\begin_layout Plain Layout

f2 <- gl(5,2)
\end_layout

\begin_layout Plain Layout

interaction(f1,f2)
\end_layout

\begin_layout Plain Layout

[1] 1.1 1.1 1.2 1.2 1.3 2.3 2.4 2.4 2.5 2.5
\end_layout

\begin_layout Plain Layout

10 Levels: [1] 1.1 1.1 1.2 1.2 1.3 2.3 2.4 2.4 2.5 2.5
\end_layout

\begin_layout Plain Layout

str(split(x, list(f1,f2), drop = True))
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
This can be useful (for example) if you want to divide people based on multiple
 pieces of demographic information.
\end_layout

\end_deeper
\begin_layout Subsection*
Debugging tools in R
\end_layout

\begin_layout Itemize
First step: diagnosing the problem.
\end_layout

\begin_layout Itemize
Indications that there is a problem:
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
message
\family default
: a generic notification/diagnostic message produced by the 
\family typewriter
message
\family default
 function; execution continues.
\end_layout

\begin_layout Itemize

\family typewriter
warning
\family default
: indicates that something is wrong but not necessarily fatal; execution
 of the function continues; generated by the 
\family typewriter
warning
\family default
 function.
\end_layout

\begin_layout Itemize

\family typewriter
error
\family default
: a fatal problem has occurred; execution stop; produced by the 
\family typewriter
stop
\family default
 function.
\end_layout

\begin_layout Itemize

\family typewriter
condition
\family default
: a generic concept for indicating that something unexpected can occur;
 programmers can create their own conditions.
\end_layout

\end_deeper
\begin_layout Itemize
Things to think about:
\end_layout

\begin_deeper
\begin_layout Itemize
What was your input? How did you call the function?
\end_layout

\begin_layout Itemize
What were you expecting? Output, messages, other results?
\end_layout

\begin_layout Itemize
What did you get? How does this differ from your expectations?
\end_layout

\begin_layout Itemize
Were your expectations correct in the first place?
\end_layout

\begin_layout Itemize
Can you reproduce the problem exactly? (can be hard if random numbers are
 involved)
\end_layout

\end_deeper
\begin_layout Itemize
Primary debugging tools in R:
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
traceback
\family default
: prints out the function call stack after an error occurs; does nothing
 if there's no error.
\end_layout

\begin_layout Itemize

\family typewriter
debug
\family default
: flags a function for 
\begin_inset Quotes eld
\end_inset

debug
\begin_inset Quotes erd
\end_inset

 mode which allows you to step through the execution of a function one line
 at a time.
\end_layout

\begin_layout Itemize

\family typewriter
browser
\family default
: suspends the execution of a function wherever it is called and puts the
 function in debug mode.
\end_layout

\begin_layout Itemize

\family typewriter
trace
\family default
: allows you to insert debugging code into a function at specific places.
\end_layout

\begin_layout Itemize

\family typewriter
recover
\family default
: allows you to modify the error behavior so that you can browse the function
 call stack.
\end_layout

\begin_deeper
\begin_layout Itemize
To use in the command line, enter 
\family typewriter
options(error = recover)
\family default
.
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
These tools are all 
\emph on
interactive
\emph default
, which is very useful!
\end_layout

\end_body
\end_document
